import { GoogleMap, InfoWindow } from "@react-google-maps/api";
import CarPopup from "../../../components/common/CarPopup";
import { useEffect, useRef, useMemo, useState } from "react";
import Supercluster from "supercluster";
import { useDispatch, useSelector } from "react-redux";
import { openGeoFenceModal } from "../../../store/modalsSlice";
import { carPath } from "../../../services/carPath";
import { getCarStatus } from "../../../utils/getCarStatus";
import {
  changeZoom,
  setClusters,
  toggleClusters,
} from "../../../store/mapSlice";

const GoogleMapView = ({
  cars,
  center,
  zoom,
  selectedCarId,
  handleSelectCar,
}) => {
  const mapRef = useRef(null);
  const drawingManagerRef = useRef(null);
  const superclusterRef = useRef(null);
  const [clusterMarkers, setClusterMarkers] = useState([]);

  const {
    clusters,
    mapType,
    showDeviceName,
    provider: mapProvider,
  } = useSelector((state) => state.map);

  const dispatch = useDispatch();

  const onLoad = (map) => {
    mapRef.current = map;
  };

  const memoizedCars = useMemo(
    () => cars,
    [
      cars
        .map(
          (c) =>
            c.id + c.position?.lat + c.position?.lng + c.direction + c.speed
        )
        .join(","),
    ]
  );

  // ✅ تحويل السيارات إلى GeoJSON features لـ Supercluster
  const geojsonFeatures = useMemo(() => {
    return memoizedCars
      .filter((car) => car.position?.lat && car.position?.lng)
      .map((car) => ({
        type: "Feature",
        properties: {
          cluster: false,
          carId: car.id,
          car: car,
        },
        geometry: {
          type: "Point",
          coordinates: [car.position.lng, car.position.lat],
        },
      }));
  }, [memoizedCars]);

  // ✅ إنشاء/تحديث Supercluster
  useEffect(() => {
    if (!geojsonFeatures.length) return;

    if (!superclusterRef.current) {
      superclusterRef.current = new Supercluster({
        radius: 60,
        maxZoom: 18,
        minPoints: 3,
      });
    }

    superclusterRef.current.load(geojsonFeatures);
  }, [geojsonFeatures]);

  // ✅ إنشاء ماركر بعلامة Symbol
  const createRotatedMarker = (car, map) => {
    const { color } = getCarStatus(car);
    const rotation = car.direction || 0;

    const markerOptions = {
      position: car.position,
      map,
      icon: {
        path: carPath,
        fillColor: color,
        fillOpacity: 1,
        strokeColor: "#000",
        strokeWeight: 0.7,
        scale: 0.05,
        rotation: rotation,
        anchor: new window.google.maps.Point(156, 256),
        labelOrigin: new window.google.maps.Point(156, 700),
      },
    };

    const marker = new window.google.maps.Marker(markerOptions);
    marker.addListener("click", () => handleSelectCar(car));
    return marker;
  };

  // ✅ إعادة بناء الماركرات فقط عند تغيير provider أو IDs
  useEffect(() => {
    if (!mapRef.current || !window.google) return;

    if (window.carMarkers) {
      Array.from(window.carMarkers.values()).forEach((m) => m.setMap(null));
    }

    window.carMarkers = new Map();

    memoizedCars.forEach((car) => {
      if (!car.position) return;
      const { color } = getCarStatus(car);

      const marker = new window.google.maps.Marker({
        position: car.position,
        map: clusters ? null : mapRef.current,
        icon: {
          path: carPath,
          fillColor: color,
          fillOpacity: 1,
          strokeColor: "#000",
          strokeWeight: 0.7,
          scale: 0.05,
          rotation: car.direction || 0,
          anchor: new window.google.maps.Point(156, 256),
          labelOrigin: new window.google.maps.Point(156, 700),
        },
      });
      marker.addListener("click", () => handleSelectCar(car));
      window.carMarkers.set(car.id, marker);
    });
  }, [mapRef.current]);

  // ✅ تحديث Clusters عند تغيير الزوم أو تفعيل/إلغاء التجميع
  useEffect(() => {
    if (!mapRef.current || !window.google || !superclusterRef.current) return;

    const map = mapRef.current;

    if (!window.clusterMarkersArray) window.clusterMarkersArray = [];

    if (!clusters) {
      // إخفاء كل cluster markers
      window.clusterMarkersArray.forEach((m) => m.setMap(null));
      window.clusterMarkersArray = [];

      // إظهار كل ماركرات العربيات
      if (window.carMarkers) {
        window.carMarkers.forEach((marker) => {
          marker.setMap(map);
          marker.setVisible(true);
        });
      }
      return;
    }

    // الكلاستر شغال
    // إخفاء كل الماركرات الفردية
    if (window.carMarkers) {
      window.carMarkers.forEach((marker) => marker.setVisible(false));
    }

    // مسح Cluster markers القديمة
    window.clusterMarkersArray.forEach((m) => m.setMap(null));
    window.clusterMarkersArray = [];

    const bounds = map.getBounds();
    if (!bounds) return;

    const bbox = [
      bounds.getSouthWest().lng(),
      bounds.getSouthWest().lat(),
      bounds.getNorthEast().lng(),
      bounds.getNorthEast().lat(),
    ];

    const currentZoom = map.getZoom();
    const clustersData = superclusterRef.current.getClusters(bbox, currentZoom);

    clustersData.forEach((feature) => {
      const [lng, lat] = feature.geometry.coordinates;
      const position = { lat, lng };

      if (feature.properties.cluster) {
        // Cluster marker
        const marker = new window.google.maps.Marker({
          position,
          map,
          icon: {
            path: window.google.maps.SymbolPath.CIRCLE,
            fillColor: "#2196F3",
            fillOpacity: 0.85,
            strokeColor: "#fff",
            strokeWeight: 2,
            scale: 20,
          },
          label: {
            text: String(feature.properties.point_count),
            color: "#fff",
            fontWeight: "bold",
            fontSize: "14px",
          },
          zIndex: 1000,
        });

        marker.addListener("click", () => {
          const expansionZoom = superclusterRef.current.getClusterExpansionZoom(
            feature.properties.cluster_id
          );
          map.setZoom(expansionZoom);
          map.panTo(position);
        });

        window.clusterMarkersArray.push(marker);
      } else {
        // ماركر فردي → نظهره
        const car = feature.properties.car;
        const marker = window.carMarkers?.get(car.id);
        if (marker) {
          marker.setVisible(true);
          marker.setMap(map); // أهم خطوة عشان يظهر
        }
      }
    });
  }, [zoom, clusters]);

  // ✅ إدارة الماركرات والتحديثات
  useEffect(() => {
    if (!mapRef.current || !window.google) return;
    const map = mapRef.current;

    if (!window.carMarkers) window.carMarkers = new Map();

    const markers = window.carMarkers;
    const currentIds = memoizedCars.map((c) => c.id);
    const existingIds = Array.from(markers.keys());

    memoizedCars.forEach((car) => {
      const marker = markers.get(car.id);
      const rotation = car.direction || 0;
      const { color } = getCarStatus(car);

      if (!marker) {
        const newMarker = createRotatedMarker(car, null); // إنشاء بدون map
        markers.set(car.id, newMarker);
      } else {
        marker.setPosition(car.position);
        const icon = marker.getIcon();
        if (icon.rotation !== rotation || icon.fillColor !== color) {
          marker.setIcon({ ...icon, rotation, fillColor: color });
        }

        if (showDeviceName) {
          marker.setLabel({
            text: car.name || "بدون اسم",
            color: "#212121",
            fontWeight: "bold",
            fontSize: "12px",
            className: "car-label",
          });
        } else {
          marker.setLabel(null);
        }
      }
    });

    existingIds.forEach((id) => {
      if (!currentIds.includes(id)) {
        const m = markers.get(id);
        if (m) {
          m.setMap(null);
          markers.delete(id);
        }
      }
    });
  }, [memoizedCars, showDeviceName, mapProvider]);

  // ✅ تحديث المواقع والاتجاه أثناء الحركة
  useEffect(() => {
    if (!window.carMarkers) return;
    memoizedCars.forEach((car) => {
      const marker = window.carMarkers.get(car.id);
      if (marker) {
        const icon = marker.getIcon();
        marker.setPosition(car.position);
        if (
          icon.rotation !== car.direction ||
          icon.fillColor !== getCarStatus(car).color
        ) {
          marker.setIcon({
            ...icon,
            rotation: car.direction,
            fillColor: getCarStatus(car).color,
          });
        }
      }
    });
  }, [memoizedCars]);

  // ##########################################
  // ✅ رسم الجيوفنس
  // ##########################################
  useEffect(() => {
    const handleDrawingStart = (e) => {
      const { type } = e.detail;
      if (!window.google || !mapRef.current) return;

      if (!window.google.maps.drawing) {
        console.error("Google Maps Drawing library not loaded");
        return;
      }

      if (drawingManagerRef.current) {
        drawingManagerRef.current.setMap(null);
      }

      const manager = new window.google.maps.drawing.DrawingManager({
        drawingMode:
          type === "circle"
            ? window.google.maps.drawing.OverlayType.CIRCLE
            : window.google.maps.drawing.OverlayType.POLYGON,
        drawingControl: false,
        circleOptions: {
          fillColor: "#2196F3",
          fillOpacity: 0.3,
          strokeColor: "#0D47A1",
          strokeWeight: 2,
          editable: true,
          draggable: true,
        },
        polygonOptions: {
          fillColor: "#4CAF50",
          fillOpacity: 0.3,
          strokeColor: "#1B5E20",
          strokeWeight: 2,
          editable: true,
          draggable: true,
        },
      });

      manager.setMap(mapRef.current);
      drawingManagerRef.current = manager;

      window.google.maps.event.addListener(manager, "overlaycomplete", (ev) => {
        let overlay = ev.overlay;
        if (ev.type === "circle") {
          const center = overlay.getCenter();
          const radius = overlay.getRadius();
          const circleData = {
            type: "circle",
            center: center.toJSON(),
            radius: radius.toFixed(2),
          };

          dispatch(
            openGeoFenceModal({ fenceData: circleData, mission: "add" })
          );
        } else if (ev.type === "polygon") {
          const path = overlay
            .getPath()
            .getArray()
            .map((p) => p.toJSON());
          const polygonData = { type: "polygon", path };

          dispatch(
            openGeoFenceModal({ fenceData: polygonData, mission: "add" })
          );
        }

        overlay.setEditable(false);
        overlay.setDraggable(false);
        manager.setDrawingMode(null);
        window.currentShape = overlay;
      });
    };

    const handleEditShape = (event) => {
      const { type, polygonData, center, radius } = event.detail;
      if (!window.google || !mapRef.current) return;
      const map = mapRef.current;

      if (window.currentShape) window.currentShape.setMap(null);

      if (type === "polygon") {
        const polygon = new window.google.maps.Polygon({
          paths: polygonData,
          strokeColor: "#FF0000",
          strokeOpacity: 0.8,
          strokeWeight: 2,
          fillColor: "#FF0000",
          fillOpacity: 0.35,
        });
        polygon.setMap(map);
        window.currentShape = polygon;

        const bounds = new window.google.maps.LatLngBounds();
        polygonData.forEach((point) => bounds.extend(point));
        map.fitBounds(bounds);
      }

      if (type === "circle") {
        const circle = new window.google.maps.Circle({
          center,
          radius,
          strokeColor: "#FF5722",
          strokeOpacity: 0.8,
          strokeWeight: 2,
          fillColor: "#FF9800",
          fillOpacity: 0.35,
        });
        circle.setMap(map);
        window.currentShape = circle;

        const bounds = new window.google.maps.LatLngBounds();
        const north = window.google.maps.geometry.spherical.computeOffset(
          center,
          radius,
          0
        );
        const south = window.google.maps.geometry.spherical.computeOffset(
          center,
          radius,
          180
        );
        const east = window.google.maps.geometry.spherical.computeOffset(
          center,
          radius,
          90
        );
        const west = window.google.maps.geometry.spherical.computeOffset(
          center,
          radius,
          270
        );
        bounds.extend(north);
        bounds.extend(south);
        bounds.extend(east);
        bounds.extend(west);
        map.fitBounds(bounds);
      }
    };

    const handleClearShape = () => {
      if (window.currentShape) {
        window.currentShape.setMap(null);
        window.currentShape = null;
      }
    };

    const handleShowAllPolygons = (event) => {
      const { fences } = event.detail;
      if (!window.google || !mapRef.current || !fences) return;

      const map = mapRef.current;

      if (window.allShapes) {
        window.allShapes.forEach((shape) => shape.setMap(null));
      }
      window.allShapes = [];

      const bounds = new window.google.maps.LatLngBounds();

      fences.forEach((fence, index) => {
        let shape;

        if (
          fence.type === "circle" &&
          fence.latitude &&
          fence.longitude &&
          fence.radius
        ) {
          shape = new window.google.maps.Circle({
            center: {
              lat: parseFloat(fence.latitude),
              lng: parseFloat(fence.longitude),
            },
            radius: parseFloat(fence.radius),
            strokeColor: "#FF5722",
            strokeOpacity: 0.8,
            strokeWeight: 2,
            fillColor: getColorByIndex(index),
            fillOpacity: 0.35,
            map: map,
          });

          const center = shape.getCenter();
          const radius = shape.getRadius();
          const north = window.google.maps.geometry.spherical.computeOffset(
            center,
            radius,
            0
          );
          const south = window.google.maps.geometry.spherical.computeOffset(
            center,
            radius,
            180
          );
          const east = window.google.maps.geometry.spherical.computeOffset(
            center,
            radius,
            90
          );
          const west = window.google.maps.geometry.spherical.computeOffset(
            center,
            radius,
            270
          );

          bounds.extend(north);
          bounds.extend(south);
          bounds.extend(east);
          bounds.extend(west);
        } else if (
          fence.type === "polygon" &&
          fence.coordinates &&
          fence.coordinates.length > 0
        ) {
          const paths = fence.coordinates.map((coord) =>
            Array.isArray(coord) ? { lat: coord[0], lng: coord[1] } : coord
          );

          shape = new window.google.maps.Polygon({
            paths: paths,
            strokeColor: "#2196F3",
            strokeOpacity: 0.8,
            strokeWeight: 2,
            fillColor: getColorByIndex(index),
            fillOpacity: 0.35,
            map: map,
          });

          paths.forEach((point) => bounds.extend(point));
        }

        if (shape) window.allShapes.push(shape);
      });

      if (!bounds.isEmpty()) {
        map.fitBounds(bounds);

        if (bounds.toSpan().lat() < 0.001 || bounds.toSpan().lng() < 0.001) {
          map.setZoom(map.getZoom() - 2);
        }
      }
    };

    const getColorByIndex = (index) => {
      const colors = [
        "#FF5722",
        "#2196F3",
        "#4CAF50",
        "#FF9800",
        "#9C27B0",
        "#00BCD4",
        "#8BC34A",
        "#E91E63",
        "#3F51B5",
        "#009688",
        "#CDDC39",
        "#673AB7",
      ];
      return colors[index % colors.length];
    };

    window.addEventListener("start-drawing", handleDrawingStart);
    window.addEventListener("edit-shape", handleEditShape);
    window.addEventListener("clear-shape", handleClearShape);
    window.addEventListener("show-all-polygons", handleShowAllPolygons);
    return () => {
      window.removeEventListener("start-drawing", handleDrawingStart);
      window.removeEventListener("edit-shape", handleEditShape);
      window.removeEventListener("clear-shape", handleClearShape);
      window.removeEventListener("show-all-polygons", handleShowAllPolygons);
      if (window.allShapes) {
        window.allShapes.forEach((shape) => shape.setMap(null));
        window.allShapes = [];
      }
    };
  }, []);

  const handleZoomChanged = () => {
    if (!mapRef.current) return;

    const newZoom = mapRef.current.getZoom();
    dispatch(changeZoom(newZoom));
  };

  return (
    <>
      <GoogleMap
        mapContainerStyle={{ width: "100%", height: "100%" }}
        center={center}
        zoom={zoom}
        onZoomChanged={handleZoomChanged}
        onLoad={onLoad}
        onClick={() => selectedCarId && handleSelectCar(null)}
        options={{
          fullscreenControl: false,
          mapTypeControl: false,
          mapTypeId: mapType,
        }}
      >
        {selectedCarId &&
          (() => {
            const car = memoizedCars.find((c) => c.id === selectedCarId);
            if (!car) return null;
            return (
              <InfoWindow
                position={car.position}
                onCloseClick={() => handleSelectCar(null)}
                options={{ pixelOffset: new window.google.maps.Size(0, -40) }}
              >
                <CarPopup car={car} />
              </InfoWindow>
            );
          })()}
      </GoogleMap>
    </>
  );
};

export default GoogleMapView;
